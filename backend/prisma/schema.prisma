generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  fullName     String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model Bot {
  id           String     @id @default(uuid())
  name         String
  platform     Platform
  identifier   String     @unique
  credentials  Json?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  ipv6Address  String?
  aiEnabled    Boolean    @default(false)
  aiModel      String     @default("gemini-3-flash-preview")
  aiProvider   AIProvider @default(GEMINI)
  systemPrompt String?
  temperature  Float      @default(0.7)
  messageDelay Int        @default(0)
  clients      Client[]
  flows        Flow[]
  sessions     Session[]
  tools        Tool[]
  triggers     Trigger[]
}

model Session {
  id               String            @id @default(uuid())
  platform         Platform
  identifier       String
  botId            String
  name             String?
  status           SessionStatus     @default(DISCONNECTED)
  authData         Json?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  conversationLogs ConversationLog[]
  executions       Execution[]
  messages         Message[]
  bot              Bot               @relation(fields: [botId], references: [id], onDelete: Cascade)
  triggers         Trigger[]

  @@unique([botId, identifier])
}

model Trigger {
  id        String       @id @default(uuid())
  botId     String
  sessionId String?
  keyword   String
  matchType MatchType    @default(CONTAINS)
  isActive  Boolean      @default(true)
  flowId    String
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  scope     TriggerScope @default(INCOMING)
  bot       Bot          @relation(fields: [botId], references: [id], onDelete: Cascade)
  flow      Flow         @relation(fields: [flowId], references: [id], onDelete: Cascade)
  session   Session?     @relation(fields: [sessionId], references: [id], onDelete: Cascade)
}

model Flow {
  id            String      @id @default(uuid())
  botId         String
  name          String
  description   String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  cooldownMs    Int         @default(0)
  usageLimit    Int         @default(0)
  excludesFlows String[]    @default([])
  executions    Execution[]
  bot           Bot         @relation(fields: [botId], references: [id], onDelete: Cascade)
  steps         Step[]
  tools         Tool[]
  triggers      Trigger[]
}

model Step {
  id        String   @id @default(uuid())
  flowId    String
  type      StepType
  content   String?
  mediaUrl  String?
  metadata  Json?
  delayMs   Int      @default(1000)
  jitterPct Int      @default(10)
  order     Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  flow      Flow     @relation(fields: [flowId], references: [id], onDelete: Cascade)

  @@index([flowId, order])
}

model Execution {
  id              String    @id @default(uuid())
  sessionId       String
  flowId          String
  platformUserId  String
  status          String    @default("RUNNING")
  currentStep     Int       @default(0)
  variableContext Json?
  startedAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  completedAt     DateTime?
  error           String?
  trigger         String?
  flow            Flow      @relation(fields: [flowId], references: [id], onDelete: Cascade)
  session         Session   @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, platformUserId])
  @@index([status])
}

model Message {
  id          String   @id @default(uuid())
  externalId  String   @unique
  sessionId   String
  sender      String
  content     String?
  type        String
  metadata    Json?
  isProcessed Boolean  @default(false)
  createdAt   DateTime @default(now())
  fromMe      Boolean  @default(false)
  session     Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([externalId])
  @@index([sessionId])
}

model CommandLog {
  id        String   @id @default(uuid())
  name      String
  user      String
  status    String
  result    String?
  createdAt DateTime @default(now())
}

model Client {
  id                String       @id @default(uuid())
  email             String       @unique
  phoneNumber       String
  encryptedPassword String?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  botId             String
  status            ClientStatus @default(REGISTRO_PENDIENTE)
  curp              String?      @unique
  bot               Bot          @relation(fields: [botId], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([phoneNumber])
  @@index([curp])
  @@index([botId])
}

model Tool {
  id           String     @id @default(uuid())
  botId        String
  name         String
  description  String
  parameters   Json?
  actionType   String
  actionConfig Json?
  status       ToolStatus @default(ACTIVE)
  flowId       String?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  bot          Bot        @relation(fields: [botId], references: [id], onDelete: Cascade)
  flow         Flow?      @relation(fields: [flowId], references: [id], onDelete: SetNull)

  @@unique([botId, name])
  @@index([botId])
}

model ConversationLog {
  id         String   @id @default(uuid())
  sessionId  String
  role       String
  content    String?
  toolName   String?
  toolArgs   Json?
  toolResult Json?
  tokenCount Int?
  model      String?
  createdAt  DateTime @default(now())
  session    Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([sessionId, createdAt])
}

enum Platform {
  WHATSAPP
  TELEGRAM
}

enum SessionStatus {
  CONNECTED
  DISCONNECTED
  AUTHENTICATING
  FAILED
}

enum MatchType {
  EXACT
  CONTAINS
  REGEX
}

enum StepType {
  TEXT
  IMAGE
  AUDIO
  VIDEO
  DOCUMENT
  PTT
  CONDITIONAL_TIME
}

enum TriggerScope {
  INCOMING
  OUTGOING
  BOTH
}

enum AIProvider {
  OPENAI
  GEMINI
}

enum ToolStatus {
  ACTIVE
  DISABLED
}

enum ClientStatus {
  REGISTRO_PENDIENTE
  PAGO_GOBIERNO_PENDIENTE
  PAGO_GOBIERNO_REALIZADO
  EXAMEN_EN_PROCESO
  LICENCIA_LISTA
  COMPLETADO
}
